"""
Created on 13/12/15
@author: CÃ©sar Alonso
data Management & Visualization
Asignment 2 W3

"""
import pandas
import numpy
#gapminder = pandas.read_csv("/home/cesar/Enlace hacia Data Visualization/Python_projects/gapminder.csv", low_memory=False)
gapminder = pandas.read_csv('gapminder.csv', low_memory=False)

##### lowercase all DataFrame columns names
gapminder.columns = map(str.lower,gapminder.columns)

##### bug file for display formats to avoid run time errors
pandas.set_option('display.float_format', lambda x:'%f'%x)

##### Initial data: 213 rows and 16 Columns
print(len(gapminder)) #number of observations (rows)
print(len(gapminder.columns)) # number of variables (columns)

##### Eliminate columns we do not need, I have just kept hte country and the variables of interest
sub1 = gapminder[['country','breastcancerper100th','co2emissions','urbanrate']]
sub2=sub1.copy()

##### We kept 213 rows and 4 columns. some nan will drop 
print(len(sub2)) #number of observations (rows)
print(len(sub2.columns))

##### setting variables I will be working with to numeric
sub2['breastcancerper100th'] = sub2['breastcancerper100th'].convert_objects(convert_numeric=True)
sub2['co2emissions'] = sub2['co2emissions'].convert_objects(convert_numeric=True)
sub2['urbanrate'] = sub2['urbanrate'].convert_objects(convert_numeric=True)

##### Subset used for variables of interest analysis
print(sub2)

################################################################################
###########################frequency tables#####################################
##### First Variable of Interest: breastcancerper100th
factor1=pandas.qcut(sub2['breastcancerper100th'], 4)
dsubf1=sub2.groupby(factor1).size()
print (dsubf1)
##### Using Quartiles I can get % distribution to confirm the uniform ditribution between intervals
factor11 =sub2.groupby(factor1).size() *100 / len(sub2)
print (factor11)
##### Using Quartiles I can summarize per interval to obtain an idea of distribution based in breastcancerper100th intervals
sumf1=sub2.groupby(factor1).sum()
print (sumf1)
sumf11=sub2.groupby(factor1).mean()
print (sumf11)

#### 4 groups
sub2['BC100_GRP']=pandas.cut(sub2.breastcancerper100th, [1, 25, 50, 75, 102])
c1=sub2['BC100_GRP'].value_counts(sort=False, dropna=True)
print("Breat Cancer Groups 100th ocurrence")
print(c1)


##### Second Variable of Interest: co2emission
factor2=pandas.qcut(sub2['co2emissions'], 4)
dsubf2=sub2.groupby(factor2).size()
print (dsubf2)
factor22 =sub2.groupby(factor2).size() *100 / len(sub2)
print (factor22)
##### Using Quartiles I can summarize per interval to obtain an idea of distribution, but this time with co2emission intervals
sumf2=sub2.groupby(factor2).sum()
print (sumf2)
sumf22=sub2.groupby(factor2).mean()
print (sumf22)

##### 3 groups
sub2['CO2E_GRP']=pandas.cut(sub2.co2emissions, [2000000, 500000000,5000000000,350000000000],labels= ['(0, 0.5]','(0.5, 5]','(5, 350]'])
c2=sub2['CO2E_GRP'].value_counts(sort=False, dropna=True)          
print("CO2 emissions groups (billions of Tm):")                                                                      
print(c2)


##### crosstabs evaluating which BREAST CANCER 100TH OCURRENCE groups were put into CO2 EMISSION GROUPS
print("Breat Cancer Groups 100th ocurrence x CO2 emissions groups (billions of Tm):")
print (pandas.crosstab(sub2['BC100_GRP'], sub2['CO2E_GRP']))

##### Third Variable of Interest: Urbanrate
factor3=pandas.qcut(sub2['urbanrate'], 4)
#print(factor3)
dsubf3=sub2.groupby(factor3).size()
print (dsubf3)
factor33 =sub2.groupby(factor3).size() *100 / len(sub2)
print (factor33)
##### In this particual case It has no sense to summariza because the variable is a % I have used mean 
sumf3=sub2.groupby(factor3).mean()
print (sumf3)

##### 4 groups
sub2['UR_GRP']=pandas.cut(sub2.urbanrate, [0, 25, 50, 75, 100])
c3=sub2['UR_GRP'].value_counts(sort=False, dropna=True)            
print("Urban Rate groups:")                                                                    
print(c3)

#crosstabs evaluating which BREAST CANCER 100TH OCURRENCE groups were put into URBAN RATE GROUPS
print (pandas.crosstab(sub2['BC100_GRP'], sub2['UR_GRP']))
